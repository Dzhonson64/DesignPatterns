### UML диаграмма применение нескольких паттренов вместе
![UML паттерна Фабричный метод](https://github.com/Dzhonson64/DesignPatterns/blob/master/imgReadme/umlMultipatterns1.png)
![UML паттерна Фабричный метод](https://github.com/Dzhonson64/DesignPatterns/blob/master/imgReadme/umlMultipatterns2.png)

#### **Что было сделано?**

1. **Мы начали с реализаци _Quackable_**

2. **Сначала потребовалось, чтобы класс _Goose_ тоже мог использоваться в качестве _Quackable_.** Мы воспользовались паттерном _Адаптер_ (класс _GooseAdapter_), чтобы преобразовать _Goose_ в _Quackable_.
3. **Затем было решено, что вызовы _quack()_ должны подсчитываться.** Мы воспользовлись паттерном _Декоратор_ и добавили декоратор _QuackCounter_.
4. **Но клиент мог забыть добавить декоратор _QuackCounter_ к объекту.** Мы воспользовались паттерном _Абстрактная Фабрика_ для создания экземпляров. Теперь каждый раз, когда клиент хотел создать объект _Duck_, он запрашивал его у фабрики и получал объект вместе с декоратором (класс _QuackCounter_) (а если ему нужен быд объект бех декоратор использовал другую фабрику).
5. **У нас возникли проблемы управления многочисленными объектами  _Duck_, Goose и _Quackable_.** Мы воспользовались паттерном _Компоновщик_ (класс _Flonk_) для группированики объектов в коллекции. Паттерн также позволяет создавать субколлекции для управелния подмноэествами объектов. В нашей реализации также был задействован паттерн _Итератор_
6. **Наконец потребовалось организовывать оповещение клиента о вызовах _quack()_.** Мы воспользовались паттерном _Наблюдатель_, чтобы объекты _Quacklogist_ могли регистрироваться в качестве наблюдателей _Quackable_. В этой реализии тоже был применён паттерн _Итератор_. Следует отметить, что паттерн _Наблюдатель_ может применяться не только к отдельным объектам, но и к комбинациям.   
