### UML диаграмма применение нескольких паттренов вместе
![UML паттерна Фабричный метод](https://github.com/Dzhonson64/DesignPatterns/blob/master/imgReadme/umlMultipatterns1.png)
![UML паттерна Фабричный метод](https://github.com/Dzhonson64/DesignPatterns/blob/master/imgReadme/umlMultipatterns2.png)

#### **Что было сделано?**

1. **Мы начали с реализаци Quackable**

2. **Сначала потребовалось, чтобы класс Goose тоже мог использоваться в качестве Quackable.** Мы воспользовались паттерном Адаптер (класс GooseAdapter), чтобы преобразовать Goose в Quackable.
3. **Затем было решено, что вызовы quack() должны подсчитываться.** Мы воспользовлись паттерном Декоратор и добавили декоратор QuackCounter.
4. **Но клиент мог забыть добавить декоратор QuackCounter к объекту.** Мы воспользовались паттерном Абстрактная Фабрика для создания экземпляров. Теперь каждый раз, когда клиент хотел создать объект Duck, он запрашивал его у фабрики и получал объект вместе с декоратором (класс QuackCounter) (а если ему нужен быд объект бех декоратор использовал другую фабрику).
5. **Унас возникли проблемы управления многочисленными объектами  Duck, Goose и Quackable.** Мы воспользовались паттерном Компоновщик (класс Flonk) для группированики объектов в коллекции. Паттерн также позволяет создавать субколлекции для управелния подмноэествами объектов. В нашей реализации также был задействован паттерн Итератор
6. **Наконец потребовалось организовывать оповещение клиента о вызовах quack().** Мы воспользовались паттерном Наблюдатель, чтобы объекты Quacklogist могли регистрироваться в качестве наблюдателей Quackable. В этой реализии тоже был применён паттерн Итератор. Следует отметить, что паттерн Наблядатель может применяться не только к отдельным объектам, но и к комбинациям.   
